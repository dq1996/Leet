package LeetCode._193_有效电话号码;

/*
 * 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，
 * 写一个 bash 脚本输出所有有效的电话号码。
 * 你可以假设一个有效的电话号码必须满足以下两种格式： 
 * (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
 * 你也可以假设每行前后没有多余的空格字符。
 * 
 * 示例:
 * 假设 file.txt 内容如下：
 * 987-123-4567
 * 123 456 7890
 * (123) 456-7890
 * 
 * 你的脚本应当输出下列有效的电话号码：
 * 987-123-4567
 * (123) 456-7890
 */

/*
 * 思路：
 * 1、(xxx) xxx-xxxx正则表达式为^\([0-9]{3}\) [0-9]{3}\-[0-9]{4}$，注意括号后的0
 * 2、xxx-xxx-xxxx正则表达式为^[0-9]{3}\-[0-9]{3}\-[0-9]{4}$
 * 3、最终正则表达式为^(\([0-9]{3}\) |[0-9]{3}\-)[0-9]{3}\-[0-9]{4}$
 * 4、使用grep/awk/gawk来进行格式化输出。
 * 
 * 时间复杂度O(1)、空间复杂度O(1)
 */
public class Solution {

	public static void main(String[] args) {
		// bash命令
		//-P必须大写
		//^和$分别表示起始和终止符
		//特殊符号(使用转义字符\(
		//|表示两者间选择一个
//		grep -P '^(\([0-9]{3}\) |[0-9]{3}\-)[0-9]{3}\-[0-9]{4}$' file.txt
//		awk '/^(\([0-9]{3}\) |[0-9]{3}\-)[0-9]{3}\-[0-9]{4}$/' file.txt
//		gawk '/^(\([0-9]{3}\) |[0-9]{3}\-)[0-9]{3}\-[0-9]{4}$/' file.txt
	}

}
